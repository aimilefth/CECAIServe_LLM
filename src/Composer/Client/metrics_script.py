"""
Author: Aimilios Leftheriotis
Affiliations: Microlab@NTUA, VLSILab@UPatras

This script automates the process of running multiple inference requests and collecting performance metrics from an AI server. It ensures that the client can send requests, retrieve metrics, and handle retries, storing the output in a structured format.

Overview:
- The script repeatedly sends inference requests to a server.
- Collects performance metrics after a defined number of requests.
- Stores the collected metrics and logs in a specified directory with a unique identifier.

Environment Variables:
- NUMBER_OF_REQUESTS: Number of requests to send for inference.
- CLIENT_APP: Path to the client application script.
- SERVER_IP: IP address of the server.
- SERVER_PORT: Port number of the server.
- MOUNTED_DIR: Directory where the output files will be stored.
- METRICS_OUTPUT: Path to the metrics output file.
- LOG_FILE: Path to the log file.

Methods:
- add_num_threads_to_instance_UID(instance_uid, metrics_data): Appends the number of threads to the instance UID.
- check_output_format(output): Validates the output format of the inference request.
- main(): Main function to execute the script.

DO NOT edit this file directly.
"""

import os
import subprocess
import sys
import json
import shutil
import time
import re

def create_instance_UID(metrics_data):
    """
    Creates the instance UID based on the metrics data.

    Args:
        metrics_data (list): List of dictionaries containing metrics data.

    Returns:
        str: The constructed instance UID.
    """
    try:
        # Extract fields from the first dictionary
        app_name = metrics_data[0]['app_name']
        network_name = metrics_data[0]['network_name']
        device = metrics_data[0]['device']
        precision = metrics_data[0]['precision']
        
        # Extract fields from the second dictionary
        SERVER_MODE = metrics_data[1]['SERVER_MODE']
        BATCH_SIZE = metrics_data[1]['BATCH_SIZE']
        NODE_NAME = metrics_data[1]['NODE_NAME']
        AIF_timestamp = metrics_data[1]['AIF_timestamp']
        
        # Construct the instance UID
        instance_uid = f"{app_name}:{network_name}:{device}:{precision}:{SERVER_MODE}:{BATCH_SIZE:03d}:{NODE_NAME}:{AIF_timestamp}"
        return instance_uid
    except KeyError as e:
        sys.exit(f"Error: Missing key {e} in metrics data.")

def check_output_format(output):
    """
    Validates the output to ensure the inference POST request was successful (HTTP status code 200).

    Args:
        output (str): The output string to validate.

    Returns:
        bool: True if the output indicates success, False otherwise.
    """
    success = False
    # Regular expression pattern to match the HTTP status code
    pattern = r'"POST /api/infer HTTP/1\.1" (\d{3})'
    
    # Search each line for the pattern
    for line in output.strip().split('\n'):
        match = re.search(pattern, line)
        if match:
            status_code = int(match.group(1))
            if status_code == 200:
                success = True
                print(output)  # Optionally print the output
            else:
                print(f"Request failed with status code {status_code}")
            break  # Exit the loop after finding the status code
    
    if not success:
        print('The request was not completed successfully')
    return success

def main():
    """
    Main function to execute the script. Sends inference requests, collects metrics, and stores the output files.
    """
    # Check if all required environment variables are set
    required_vars = ['NUMBER_OF_REQUESTS', 'NUMBER_OF_WARMUPS', 'CLIENT_APP', 'SERVER_IP', 'SERVER_PORT', 'MOUNTED_DIR', 'METRICS_OUTPUT', 'POWER_METRICS_OUTPUT', 'SERVER_LOGS_OUTPUT', 'LOG_FILE']
    for var in required_vars:
        if var not in os.environ:
            sys.exit(f"Error: The environment variable {var} is not set.")
        

    NUMBER_OF_REQUESTS = int(os.environ['NUMBER_OF_REQUESTS'])
    NUMBER_OF_WARMUPS = int(os.environ['NUMBER_OF_WARMUPS'])
    CLIENT_APP = os.environ['CLIENT_APP']
    MOUNTED_DIR = os.environ['MOUNTED_DIR']
    METRICS_OUTPUT = os.environ['METRICS_OUTPUT']
    POWER_METRICS_OUTPUT = os.environ['POWER_METRICS_OUTPUT']
    SERVER_LOGS_OUTPUT = os.environ['SERVER_LOGS_OUTPUT']
    LOG_FILE = os.environ['LOG_FILE']

    TEMP_WARMUP_METRICS_OUTPUT = 'temp_warmup_metrics_output.json'

    # Run the inference command for NUMBER_OF_WARMUPS times
    for _ in range(NUMBER_OF_WARMUPS):
        result = subprocess.run(["python3", CLIENT_APP], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
        while not check_output_format(result.stdout):
            time.sleep(1)
            result = subprocess.run(["python3", CLIENT_APP], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)

    # Run the get metrics command for the warmups
    subprocess.run(["python3", CLIENT_APP, "-m", "True", "-n", str(NUMBER_OF_WARMUPS)])

    shutil.move(METRICS_OUTPUT, TEMP_WARMUP_METRICS_OUTPUT)

    # Run the inference command for NUMBER_OF_REQUESTS times
    for _ in range(NUMBER_OF_REQUESTS):
        result = subprocess.run(["python3", CLIENT_APP], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
        while not check_output_format(result.stdout):
            time.sleep(1)
            result = subprocess.run(["python3", CLIENT_APP], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)

    # Run the get metrics command
    subprocess.run(["python3", CLIENT_APP, "-m", "True", "-n", str(NUMBER_OF_REQUESTS)])

    # Run the get power command
    subprocess.run(["python3", CLIENT_APP, "-p", "True"])

    # Run the get logs command
    subprocess.run(["python3", CLIENT_APP, "-l", "True"])

    # Run the shutdown command
    subprocess.run(["python3", CLIENT_APP, "-s", "True"])

    # Load the metrics.json file
    try:
        with open(METRICS_OUTPUT, 'r') as f:
            metrics_data = json.load(f)
    except FileNotFoundError:
        sys.exit(f"Error: File {METRICS_OUTPUT} not found.")

    # Create the instance UID
    instance_uid = create_instance_UID(metrics_data)

    # Copy the files to the mounted directory with the new name
    shutil.copy(TEMP_WARMUP_METRICS_OUTPUT, os.path.join(MOUNTED_DIR, f'{instance_uid}_warmup.json'))
    shutil.copy(METRICS_OUTPUT, os.path.join(MOUNTED_DIR, f'{instance_uid}_metrics.json'))
    shutil.copy(POWER_METRICS_OUTPUT, os.path.join(MOUNTED_DIR, f'{instance_uid}_power.json'))
    shutil.copy(SERVER_LOGS_OUTPUT, os.path.join(MOUNTED_DIR, f'{instance_uid}_server.log'))
    shutil.copy(LOG_FILE, os.path.join(MOUNTED_DIR, f'{instance_uid}_client.log'))

    # Change the permissions of the files to full permissions (read, write, execute for owner, group, others)
    os.chmod(os.path.join(MOUNTED_DIR, f'{instance_uid}_warmup.json'), 0o777)
    os.chmod(os.path.join(MOUNTED_DIR, f'{instance_uid}_metrics.json'), 0o777)
    os.chmod(os.path.join(MOUNTED_DIR, f'{instance_uid}_power.json'), 0o777)
    os.chmod(os.path.join(MOUNTED_DIR, f'{instance_uid}_server.log'), 0o777)
    os.chmod(os.path.join(MOUNTED_DIR, f'{instance_uid}_client.log'), 0o777)

if __name__ == '__main__':
    main()
